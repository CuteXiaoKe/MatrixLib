<p>I think I have developed MatrixLib to the point where it could be potentially useful, so I am issuing what I suppose I could call a beta release. I set up the <a href="http://jmatrixlib.sf.net">main website</a> with <a href="http://jmatrixlib.sf.net/doc">documentation</a> on SourceForge.</p>
<p>One aspect of MatrixLib that still needs improvement is calculating eigenvalues and eigenvectors. The current implementation of the QR algorithm will not converge for sufficiently large matrices with all complex entries, and eigenvector computation is for some reason incorrect for some matrices.</p>
<p>There are other useful factorizations that could be implemented without much difficulty. One is the Singular Value Decomposition, which can be used for solving linear systems, least squares minimization, and a variety of applications in science and engineering (such as implementing the Kabsch algorithm, which is useful for computing information about the structures of molecules).</p>
<p>Another useful factorization is the Jordan decomposition, which writes a matrix in the Jordan canonical form. A Jordan block is a square matrix which has equal diagonal elements, a first superdiagonal composed of 1's, and zeros everywhere else; a matrix is in Jordan canonical form if it has Jordan blocks on its diagonals and zeros everywhere else. Every square matrix is similar to a matrix in Jordan canonical form.</p>
<p>A variety of common mathematical functions such as sin and exp have a natural extension to the domain of square matrices based on the computation of their power series. For example, for a matrix $$A$$ we have</p>
<p>\[e^A = \sum_{n=0}^{\infty} \frac{1}{n!} A^n = I + A + \frac{1}{2}A^2 + \frac{1}{6}A^3 + \cdots\]</p>
<p>There are ways of computing such functions for matrices in a finite number of steps. However, the computation is greatly simplified for matrices in Jordan canonical form. If $$J$$ is a Jordan block with $$\lambda$$ along the diagonal and $$f:\mathrm{Mat}_{\mathbb{C}}(n,n)\rightarrow\mathrm{Mat}_{\mathbb{C}}(n,n)$$ is a holomorphism, we have</p>
<p>\[[f(J)]_{ij} = \frac{1}{(j-i)!} f^{(j-i)}(\lambda).\]</p>
<p>Moreover, if $$\lambda$$ is an eigenvalue of $$J$$, then $$f(\lambda)$$ is an eigenvalue of $$f(J)$$.</p>
<p>Another consideration for future development of MatrixLib has been to implement an abstract class representing a mathematical expression. This way, everything could be computed symbolically in terms of fractions (integer tuples) and perhaps a stack of operations, such as square root. This would eliminate any problems with numerical stability, as no decimal computation would be used. In this case, MatrixLib would begin to resemble a computer algebra system more than a numerical library.</p>